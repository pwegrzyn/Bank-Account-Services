# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.2
#
# <auto-generated>
#
# Generated from file `bank.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module generated
_M_generated = Ice.openModule('generated')
__name__ = 'generated'

# Start of module generated.bank
_M_generated.bank = Ice.openModule('generated.bank')
__name__ = 'generated.bank'

if 'Currency' not in _M_generated.bank.__dict__:
    _M_generated.bank.Currency = Ice.createTempClass()
    class Currency(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Currency.PLN = Currency("PLN", 0)
    Currency.EUR = Currency("EUR", 1)
    Currency.USD = Currency("USD", 2)
    Currency.JPY = Currency("JPY", 3)
    Currency.CHF = Currency("CHF", 4)
    Currency.CNH = Currency("CNH", 5)
    Currency._enumerators = { 0:Currency.PLN, 1:Currency.EUR, 2:Currency.USD, 3:Currency.JPY, 4:Currency.CHF, 5:Currency.CNH }

    _M_generated.bank._t_Currency = IcePy.defineEnum('::generated::bank::Currency', Currency, (), Currency._enumerators)

    _M_generated.bank.Currency = Currency
    del Currency

if 'AccountType' not in _M_generated.bank.__dict__:
    _M_generated.bank.AccountType = Ice.createTempClass()
    class AccountType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    AccountType.STANDARD = AccountType("STANDARD", 0)
    AccountType.PREMIUM = AccountType("PREMIUM", 1)
    AccountType._enumerators = { 0:AccountType.STANDARD, 1:AccountType.PREMIUM }

    _M_generated.bank._t_AccountType = IcePy.defineEnum('::generated::bank::AccountType', AccountType, (), AccountType._enumerators)

    _M_generated.bank.AccountType = AccountType
    del AccountType

if 'UserData' not in _M_generated.bank.__dict__:
    _M_generated.bank.UserData = Ice.createTempClass()
    class UserData(object):
        def __init__(self, name='', surname='', pesel='', monthlyIncome=0):
            self.name = name
            self.surname = surname
            self.pesel = pesel
            self.monthlyIncome = monthlyIncome

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.surname)
            _h = 5 * _h + Ice.getHash(self.pesel)
            _h = 5 * _h + Ice.getHash(self.monthlyIncome)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_generated.bank.UserData):
                return NotImplemented
            else:
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.surname is None or other.surname is None:
                    if self.surname != other.surname:
                        return (-1 if self.surname is None else 1)
                else:
                    if self.surname < other.surname:
                        return -1
                    elif self.surname > other.surname:
                        return 1
                if self.pesel is None or other.pesel is None:
                    if self.pesel != other.pesel:
                        return (-1 if self.pesel is None else 1)
                else:
                    if self.pesel < other.pesel:
                        return -1
                    elif self.pesel > other.pesel:
                        return 1
                if self.monthlyIncome is None or other.monthlyIncome is None:
                    if self.monthlyIncome != other.monthlyIncome:
                        return (-1 if self.monthlyIncome is None else 1)
                else:
                    if self.monthlyIncome < other.monthlyIncome:
                        return -1
                    elif self.monthlyIncome > other.monthlyIncome:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_generated.bank._t_UserData)

        __repr__ = __str__

    _M_generated.bank._t_UserData = IcePy.defineStruct('::generated::bank::UserData', UserData, (), (
        ('name', (), IcePy._t_string),
        ('surname', (), IcePy._t_string),
        ('pesel', (), IcePy._t_string),
        ('monthlyIncome', (), IcePy._t_long)
    ))

    _M_generated.bank.UserData = UserData
    del UserData

if 'AccountCreationResult' not in _M_generated.bank.__dict__:
    _M_generated.bank.AccountCreationResult = Ice.createTempClass()
    class AccountCreationResult(object):
        def __init__(self, password='', accountType=_M_generated.bank.AccountType.STANDARD):
            self.password = password
            self.accountType = accountType

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.password)
            _h = 5 * _h + Ice.getHash(self.accountType)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_generated.bank.AccountCreationResult):
                return NotImplemented
            else:
                if self.password is None or other.password is None:
                    if self.password != other.password:
                        return (-1 if self.password is None else 1)
                else:
                    if self.password < other.password:
                        return -1
                    elif self.password > other.password:
                        return 1
                if self.accountType is None or other.accountType is None:
                    if self.accountType != other.accountType:
                        return (-1 if self.accountType is None else 1)
                else:
                    if self.accountType < other.accountType:
                        return -1
                    elif self.accountType > other.accountType:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_generated.bank._t_AccountCreationResult)

        __repr__ = __str__

    _M_generated.bank._t_AccountCreationResult = IcePy.defineStruct('::generated::bank::AccountCreationResult', AccountCreationResult, (), (
        ('password', (), IcePy._t_string),
        ('accountType', (), _M_generated.bank._t_AccountType)
    ))

    _M_generated.bank.AccountCreationResult = AccountCreationResult
    del AccountCreationResult

if 'Credit' not in _M_generated.bank.__dict__:
    _M_generated.bank.Credit = Ice.createTempClass()
    class Credit(object):
        def __init__(self, creditRateBaseCurrency=0, creditRateForeignCurrency=0, baseCurrency=_M_generated.bank.Currency.PLN, foreignCurrency=_M_generated.bank.Currency.PLN, creditPeriod=0, creditValue=0, interestRate=0.0, creditCost=0):
            self.creditRateBaseCurrency = creditRateBaseCurrency
            self.creditRateForeignCurrency = creditRateForeignCurrency
            self.baseCurrency = baseCurrency
            self.foreignCurrency = foreignCurrency
            self.creditPeriod = creditPeriod
            self.creditValue = creditValue
            self.interestRate = interestRate
            self.creditCost = creditCost

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_generated.bank.Credit):
                return NotImplemented
            else:
                if self.creditRateBaseCurrency != other.creditRateBaseCurrency:
                    return False
                if self.creditRateForeignCurrency != other.creditRateForeignCurrency:
                    return False
                if self.baseCurrency != other.baseCurrency:
                    return False
                if self.foreignCurrency != other.foreignCurrency:
                    return False
                if self.creditPeriod != other.creditPeriod:
                    return False
                if self.creditValue != other.creditValue:
                    return False
                if self.interestRate != other.interestRate:
                    return False
                if self.creditCost != other.creditCost:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_generated.bank._t_Credit)

        __repr__ = __str__

    _M_generated.bank._t_Credit = IcePy.defineStruct('::generated::bank::Credit', Credit, (), (
        ('creditRateBaseCurrency', (), IcePy._t_long),
        ('creditRateForeignCurrency', (), IcePy._t_long),
        ('baseCurrency', (), _M_generated.bank._t_Currency),
        ('foreignCurrency', (), _M_generated.bank._t_Currency),
        ('creditPeriod', (), IcePy._t_int),
        ('creditValue', (), IcePy._t_long),
        ('interestRate', (), IcePy._t_double),
        ('creditCost', (), IcePy._t_long)
    ))

    _M_generated.bank.Credit = Credit
    del Credit

if 'BankSystemException' not in _M_generated.bank.__dict__:
    _M_generated.bank.BankSystemException = Ice.createTempClass()
    class BankSystemException(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::BankSystemException'

    _M_generated.bank._t_BankSystemException = IcePy.defineException('::generated::bank::BankSystemException', BankSystemException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    BankSystemException._ice_type = _M_generated.bank._t_BankSystemException

    _M_generated.bank.BankSystemException = BankSystemException
    del BankSystemException

if 'AuthorizationFailed' not in _M_generated.bank.__dict__:
    _M_generated.bank.AuthorizationFailed = Ice.createTempClass()
    class AuthorizationFailed(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::AuthorizationFailed'

    _M_generated.bank._t_AuthorizationFailed = IcePy.defineException('::generated::bank::AuthorizationFailed', AuthorizationFailed, (), False, _M_generated.bank._t_BankSystemException, ())
    AuthorizationFailed._ice_type = _M_generated.bank._t_AuthorizationFailed

    _M_generated.bank.AuthorizationFailed = AuthorizationFailed
    del AuthorizationFailed

if 'PESELAlreadyInUse' not in _M_generated.bank.__dict__:
    _M_generated.bank.PESELAlreadyInUse = Ice.createTempClass()
    class PESELAlreadyInUse(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::PESELAlreadyInUse'

    _M_generated.bank._t_PESELAlreadyInUse = IcePy.defineException('::generated::bank::PESELAlreadyInUse', PESELAlreadyInUse, (), False, _M_generated.bank._t_BankSystemException, ())
    PESELAlreadyInUse._ice_type = _M_generated.bank._t_PESELAlreadyInUse

    _M_generated.bank.PESELAlreadyInUse = PESELAlreadyInUse
    del PESELAlreadyInUse

if 'InvalidCredentials' not in _M_generated.bank.__dict__:
    _M_generated.bank.InvalidCredentials = Ice.createTempClass()
    class InvalidCredentials(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::InvalidCredentials'

    _M_generated.bank._t_InvalidCredentials = IcePy.defineException('::generated::bank::InvalidCredentials', InvalidCredentials, (), False, _M_generated.bank._t_BankSystemException, ())
    InvalidCredentials._ice_type = _M_generated.bank._t_InvalidCredentials

    _M_generated.bank.InvalidCredentials = InvalidCredentials
    del InvalidCredentials

if 'CurrencyNotSupported' not in _M_generated.bank.__dict__:
    _M_generated.bank.CurrencyNotSupported = Ice.createTempClass()
    class CurrencyNotSupported(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::CurrencyNotSupported'

    _M_generated.bank._t_CurrencyNotSupported = IcePy.defineException('::generated::bank::CurrencyNotSupported', CurrencyNotSupported, (), False, _M_generated.bank._t_BankSystemException, ())
    CurrencyNotSupported._ice_type = _M_generated.bank._t_CurrencyNotSupported

    _M_generated.bank.CurrencyNotSupported = CurrencyNotSupported
    del CurrencyNotSupported

if 'InternalSystemError' not in _M_generated.bank.__dict__:
    _M_generated.bank.InternalSystemError = Ice.createTempClass()
    class InternalSystemError(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::InternalSystemError'

    _M_generated.bank._t_InternalSystemError = IcePy.defineException('::generated::bank::InternalSystemError', InternalSystemError, (), False, _M_generated.bank._t_BankSystemException, ())
    InternalSystemError._ice_type = _M_generated.bank._t_InternalSystemError

    _M_generated.bank.InternalSystemError = InternalSystemError
    del InternalSystemError

if 'SystemCurrentlyUnavailable' not in _M_generated.bank.__dict__:
    _M_generated.bank.SystemCurrentlyUnavailable = Ice.createTempClass()
    class SystemCurrentlyUnavailable(_M_generated.bank.BankSystemException):
        def __init__(self, reason=''):
            _M_generated.bank.BankSystemException.__init__(self, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::generated::bank::SystemCurrentlyUnavailable'

    _M_generated.bank._t_SystemCurrentlyUnavailable = IcePy.defineException('::generated::bank::SystemCurrentlyUnavailable', SystemCurrentlyUnavailable, (), False, _M_generated.bank._t_BankSystemException, ())
    SystemCurrentlyUnavailable._ice_type = _M_generated.bank._t_SystemCurrentlyUnavailable

    _M_generated.bank.SystemCurrentlyUnavailable = SystemCurrentlyUnavailable
    del SystemCurrentlyUnavailable

_M_generated.bank._t_Account = IcePy.defineValue('::generated::bank::Account', Ice.Value, -1, (), False, True, None, ())

if 'AccountPrx' not in _M_generated.bank.__dict__:
    _M_generated.bank.AccountPrx = Ice.createTempClass()
    class AccountPrx(Ice.ObjectPrx):

        def checkAccountBalance(self, context=None):
            return _M_generated.bank.Account._op_checkAccountBalance.invoke(self, ((), context))

        def checkAccountBalanceAsync(self, context=None):
            return _M_generated.bank.Account._op_checkAccountBalance.invokeAsync(self, ((), context))

        def begin_checkAccountBalance(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_generated.bank.Account._op_checkAccountBalance.begin(self, ((), _response, _ex, _sent, context))

        def end_checkAccountBalance(self, _r):
            return _M_generated.bank.Account._op_checkAccountBalance.end(self, _r)

        def checkAccountType(self, context=None):
            return _M_generated.bank.Account._op_checkAccountType.invoke(self, ((), context))

        def checkAccountTypeAsync(self, context=None):
            return _M_generated.bank.Account._op_checkAccountType.invokeAsync(self, ((), context))

        def begin_checkAccountType(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_generated.bank.Account._op_checkAccountType.begin(self, ((), _response, _ex, _sent, context))

        def end_checkAccountType(self, _r):
            return _M_generated.bank.Account._op_checkAccountType.end(self, _r)

        def applyForCredit(self, currency, creditValue, period, context=None):
            return _M_generated.bank.Account._op_applyForCredit.invoke(self, ((currency, creditValue, period), context))

        def applyForCreditAsync(self, currency, creditValue, period, context=None):
            return _M_generated.bank.Account._op_applyForCredit.invokeAsync(self, ((currency, creditValue, period), context))

        def begin_applyForCredit(self, currency, creditValue, period, _response=None, _ex=None, _sent=None, context=None):
            return _M_generated.bank.Account._op_applyForCredit.begin(self, ((currency, creditValue, period), _response, _ex, _sent, context))

        def end_applyForCredit(self, _r):
            return _M_generated.bank.Account._op_applyForCredit.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_generated.bank.AccountPrx.ice_checkedCast(proxy, '::generated::bank::Account', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_generated.bank.AccountPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::generated::bank::Account'
    _M_generated.bank._t_AccountPrx = IcePy.defineProxy('::generated::bank::Account', AccountPrx)

    _M_generated.bank.AccountPrx = AccountPrx
    del AccountPrx

    _M_generated.bank.Account = Ice.createTempClass()
    class Account(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::generated::bank::Account')

        def ice_id(self, current=None):
            return '::generated::bank::Account'

        @staticmethod
        def ice_staticId():
            return '::generated::bank::Account'

        def checkAccountBalance(self, current=None):
            raise NotImplementedError("servant method 'checkAccountBalance' not implemented")

        def checkAccountType(self, current=None):
            raise NotImplementedError("servant method 'checkAccountType' not implemented")

        def applyForCredit(self, currency, creditValue, period, current=None):
            raise NotImplementedError("servant method 'applyForCredit' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_generated.bank._t_AccountDisp)

        __repr__ = __str__

    _M_generated.bank._t_AccountDisp = IcePy.defineClass('::generated::bank::Account', Account, (), None, ())
    Account._ice_type = _M_generated.bank._t_AccountDisp

    Account._op_checkAccountBalance = IcePy.Operation('checkAccountBalance', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_long, False, 0), ())
    Account._op_checkAccountType = IcePy.Operation('checkAccountType', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_generated.bank._t_AccountType, False, 0), ())
    Account._op_applyForCredit = IcePy.Operation('applyForCredit', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_generated.bank._t_Currency, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0)), (), ((), _M_generated.bank._t_Credit, False, 0), (_M_generated.bank._t_CurrencyNotSupported, _M_generated.bank._t_AuthorizationFailed))

    _M_generated.bank.Account = Account
    del Account

_M_generated.bank._t_System = IcePy.defineValue('::generated::bank::System', Ice.Value, -1, (), False, True, None, ())

if 'SystemPrx' not in _M_generated.bank.__dict__:
    _M_generated.bank.SystemPrx = Ice.createTempClass()
    class SystemPrx(Ice.ObjectPrx):

        def createAccount(self, userData, context=None):
            return _M_generated.bank.System._op_createAccount.invoke(self, ((userData, ), context))

        def createAccountAsync(self, userData, context=None):
            return _M_generated.bank.System._op_createAccount.invokeAsync(self, ((userData, ), context))

        def begin_createAccount(self, userData, _response=None, _ex=None, _sent=None, context=None):
            return _M_generated.bank.System._op_createAccount.begin(self, ((userData, ), _response, _ex, _sent, context))

        def end_createAccount(self, _r):
            return _M_generated.bank.System._op_createAccount.end(self, _r)

        def logInToAccount(self, pesel, context=None):
            return _M_generated.bank.System._op_logInToAccount.invoke(self, ((pesel, ), context))

        def logInToAccountAsync(self, pesel, context=None):
            return _M_generated.bank.System._op_logInToAccount.invokeAsync(self, ((pesel, ), context))

        def begin_logInToAccount(self, pesel, _response=None, _ex=None, _sent=None, context=None):
            return _M_generated.bank.System._op_logInToAccount.begin(self, ((pesel, ), _response, _ex, _sent, context))

        def end_logInToAccount(self, _r):
            return _M_generated.bank.System._op_logInToAccount.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_generated.bank.SystemPrx.ice_checkedCast(proxy, '::generated::bank::System', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_generated.bank.SystemPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::generated::bank::System'
    _M_generated.bank._t_SystemPrx = IcePy.defineProxy('::generated::bank::System', SystemPrx)

    _M_generated.bank.SystemPrx = SystemPrx
    del SystemPrx

    _M_generated.bank.System = Ice.createTempClass()
    class System(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::generated::bank::System')

        def ice_id(self, current=None):
            return '::generated::bank::System'

        @staticmethod
        def ice_staticId():
            return '::generated::bank::System'

        def createAccount(self, userData, current=None):
            raise NotImplementedError("servant method 'createAccount' not implemented")

        def logInToAccount(self, pesel, current=None):
            raise NotImplementedError("servant method 'logInToAccount' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_generated.bank._t_SystemDisp)

        __repr__ = __str__

    _M_generated.bank._t_SystemDisp = IcePy.defineClass('::generated::bank::System', System, (), None, ())
    System._ice_type = _M_generated.bank._t_SystemDisp

    System._op_createAccount = IcePy.Operation('createAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_generated.bank._t_UserData, False, 0),), (), ((), _M_generated.bank._t_AccountCreationResult, False, 0), (_M_generated.bank._t_PESELAlreadyInUse,))
    System._op_logInToAccount = IcePy.Operation('logInToAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_generated.bank._t_AccountPrx, False, 0), (_M_generated.bank._t_InvalidCredentials,))

    _M_generated.bank.System = System
    del System

# End of module generated.bank

__name__ = 'generated'

# End of module generated
